(* Tokens *)
left_bracket   = "[" ;
right_bracket  = "]" ;
left_brace   = "{" ;
right_brace  = "}" ;
left_brackets   = "[[" ;
right_brackets  = "]]" ;
left_braces     = "{{" ;
right_braces    = "}}" ;
hash_char       = "#" ;
vertical_bar    = "|" ;
equals          = "=" ;
bullet          = "*" ;
colon           = ":" ;
comma           = "," ;
semicolon       = ";" ;
slash           = "/" ;

(* Here's our first regex-defined rule, which matches comments. Regular
   expressions are indicated with the ?/re/? syntax, which conveys an
   appropriate subtext of bafflement. *)
comment = ?/<!--(.|\n)+?-->/? ;

(* 
Whitespace matching.

Whitespace is significant on MediaWiki. Perhaps the most straightforward
example is that the text:
    
    [[link]] s

prints differently from:
    
    [[link]]s

On top of that, some things, like list syntax, apply until the end of the
line. So we need some rules for whitespace, and whenever the syntax has
optional whitespace in it, we need to explicitly allow it.

Our three whitespace symbols are:

- SP: Zero or more whitespace characters that stay on the same line.
- NL: A single newline character (\n).
- WS: Zero or more whitespace characters, possibly including newlines.
*)
SP = ?/[ \t]*/? ;
NL = ?/\n/? ;
WS = NL | SP ;

(* A "term" is a string with no wiki syntax in it. Basically, anything 
   whose characters we can consume without worrying about backtracking,
   because you can't backtrack into a regex. *)
term = ?/[^\[\]{}<>|:=\n]+/? ;

(* We don't care at all about the contents of HTML tags. They're just there.
   So, despite a frothing rant on Stack Overflow, I'll parse HTML tags with
   a regex. *)
html_tag = ?/<[^>]+?>/? ;

(* Plain text is made of terms, significant whitespace, and occasional things
   we ignore such as HTML tags and comments. It also allows miscellaneous
   symbols that look like wikitext syntax, but clearly aren't being used for
   that purpose, such as single brackets and braces.

   This rule is a simple example of where order matters in a PEG grammar: a
   comment looks like an HTML tag, but is more specific and is parsed
   differently, so we need to match it first. *)
single_left_bracket = left_bracket !left_bracket ;
single_right_bracket = right_bracket !right_bracket ;
single_left_brace = left_brace !left_brace ;
single_right_brace = right_brace !right_brace ;
one_line_text = @term | comment | html_tag | @colon | @equals 
              | @single_left_bracket | @single_right_bracket
              | @single_left_brace | @single_right_brace | @SP ;
text = @NL | @one_line_text ;


(* These rules handle not-so-plain text, which may contain links and templates,
   which are syntactic structures that will be defined below. *)
text_with_links = { wiki_link | text }+ ;
one_line_text_with_links = { wiki_link | one_line_text }+ ;
one_line_wikitext = { @+:template | @+:wiki_link | @+:external_link | @+:one_line_text }+ ;
wikitext = { @+:template | @+:wiki_link | @+:external_link | @+:text }+ ;


(*
Links look like this:

    [[target]]

Or this:

    [[target|text]]
*)
wiki_link = left_brackets [ site:term colon ] target:term [ vertical_bar text:term ] right_brackets ;


(*
External links are something we have to be able to extract text from. They look like this:

    [http://www.americanscientist.org/authors/detail/david-van-tassel David Van Tassel]
*)
linktext = { @+:term | html_tag | NL | @+:colon | @+:equals }+ ;
urlpath = ?/[^ \[\]{}<>|]+/? ;
url = schema:term colon path:urlpath ;
external_link = left_bracket url:url WS [ text:linktext ] right_bracket ;


(*
Images have complex syntax like this:

    [[Image:Stilles Mineralwasser.jpg|thumb|water (1,2)]]
*)
image = left_brackets WS "Image:" filename:term { vertical_bar wikitext }* WS right_brackets ;


(* 
A simple template looks like this:

    {{archaic}}

More complex templates take arguments, such as this translation into French:

    {{t+|fr|exemple|m}}

And very complex templates can have both positional and named arguments:

    {{t|ja|例え|tr=[[たとえ]], tatoe}}
*)
named_arg = key:term WS equals WS value:wikitext ;
template_arg = [ named:named_arg | positional:wikitext ] ;
template_args = { WS vertical_bar WS @+:template_arg }+ ;
template = left_braces WS name:term [args:template_args] right_braces ;


(* Templates that become links to words, such as {{term}} and {{l}} *)
(* TODO: make the semantics work, and include {{w}} as one of these *)
link_template_name = "term/t" | "term" | "l" | "ja-l" | "ko-inline"
    | "blend" | "borrowing" | "back-form" | "calque" | "clipping"
    | "compound" | "confix" | "-er" | "etycomp" | "prefix" | "suffix" ;
link_template = left_braces WS linktype:link_template_name { slash subtypes+:term }* args:template_args right_braces ;


(* Rules for parsing translation sections *)
translation_name = "t-simple" | "t+" | "t" | "t-" | "t0" | "tø" ;
translation_template = left_braces WS translation_name @template_args right_braces ;

checktrans_top_template = left_braces WS "checktrans-top" WS right_braces ;
sensetrans_top_template = left_braces WS "trans-top" WS vertical_bar WS sense:text_with_links WS right_braces ;
trans_top_template = { checktrans:checktrans_top_template | sensetrans:sensetrans_top_template } ;
trans_mid_template = left_braces WS "trans-mid" WS right_braces ;
trans_bottom_template = left_braces WS "trans-bottom" WS right_braces ;

translation_entry = bullet SP { translations+:translation_template | one_line_text_with_links }+ NL ;
translation_content = { trans_mid_template | @+:translation_entry | WS }+ ;

(* After parsing a translation block, we "cut", indicated by the symbol >>.
   That means the parser should not backtrack past this point after
   successfully parsing a block, and therefore it can throw out memoized
   parses before this point. *)
translation_block = top:trans_top_template WS translations:translation_content WS trans_bottom_template WS >> ;
translation_section = { translation_block }+ ;


(* Rules for parsing definition sections *)
list_chars = ?/[#*:]+/? ;
defn_line = hash_char !bullet SP @one_line_wikitext NL WS ;
defn_details = hash_char list_chars SP @one_line_wikitext NL WS ;
definition = @defn_line { defn_details }* >> ;
definition_section = { template | image | WS }* { @+:definition }+ ;


(* Rules for parsing etymology sections *)
(* The {{etyl}} template gives the language of the next term, or some list of
   upcoming terms of unspecified length. *)
etyl_template = left_braces WS "etyl" WS vertical_bar language:term WS template_args right_braces ;
etyl_link = link_template | wiki_link ;
etyl_template_and_link = etyl:etyl_template WS link:etyl_link ;
etymology_section = { @+:etyl_template_and_link | @+:link_template | template | wiki_link | external_link | text }+ ;


(* Rules for parsing link sections, such as related terms and synonyms *)
link_section = { link_line | template | WS }+ ;
sense_template = left_braces WS "sense" WS vertical_bar @text_with_links right_braces ;
link_line = bullet SP [sense:sense_template] SP { link+:link_template | link+:wiki_link | template | external_link | one_line_text }+ NL >> ;


